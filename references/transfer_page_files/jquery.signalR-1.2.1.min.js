/*!
 * ASP.NET SignalR JavaScript Library v1.2.1
 * http://signalr.net/
 *
 * Copyright Microsoft Open Technologies, Inc. All rights reserved.
 * Licensed under the Apache 2.0
 * https://github.com/SignalR/SignalR/blob/master/LICENSE.md
 *
 */
(function (f, i, r) { "use strict"; if (typeof f !== "function") { throw new Error("SignalR: jQuery not found. Please ensure jQuery is referenced before the SignalR.js file.") } if (!i.JSON) { throw new Error("SignalR: No JSON parser found. Please ensure json2.js is referenced before the SignalR.js file if you need to support clients without native JSON parsing support, e.g. IE<8.") } var d, e, g = i.document.readyState === "complete", p = f(i), v = { onStart: "onStart", onStarting: "onStarting", onReceived: "onReceived", onError: "onError", onConnectionSlow: "onConnectionSlow", onReconnecting: "onReconnecting", onReconnect: "onReconnect", onStateChanged: "onStateChanged", onDisconnect: "onDisconnect" }, t = { processData: true, timeout: null, async: true, global: false, cache: false }, n = function (e, t) { if (t === false) { return } var n; if (typeof i.console === "undefined") { return } n = "[" + (new Date).toTimeString() + "] SignalR: " + e; if (i.console.debug) { i.console.debug(n) } else if (i.console.log) { i.console.log(n) } }, m = function (e, t, n) { if (t === e.state) { e.state = n; f(e).triggerHandler(v.onStateChanged, [{ oldState: t, newState: n }]); return true } return false }, o = function (e) { return e.state === d.connectionState.disconnected }, h = function (e) { var t, n; if (!e._.configuredStopReconnectingTimeout) { n = function (e) { e.log("Couldn't reconnect within the configured timeout (" + e.disconnectTimeout + "ms), disconnecting."); e.stop(false, false) }; e.reconnecting(function () { var e = this; if (e.state === d.connectionState.reconnecting) { t = i.setTimeout(function () { n(e) }, e.disconnectTimeout) } }); e.stateChanged(function (e) { if (e.oldState === d.connectionState.reconnecting) { i.clearTimeout(t) } }); e._.configuredStopReconnectingTimeout = true } }; d = function (e, t, n) { return new d.fn.init(e, t, n) }; d._ = { defaultContentType: "application/x-www-form-urlencoded; charset=UTF-8", ieVersion: function () { var e, t; if (i.navigator.appName === "Microsoft Internet Explorer") { t = /MSIE ([0-9]+\.[0-9]+)/.exec(i.navigator.userAgent); if (t) { e = i.parseFloat(t[1]) } } return e }(), firefoxMajorVersion: function (e) { var t = e.match(/Firefox\/(\d+)/); if (!t || !t.length || t.length < 2) { return 0 } return parseInt(t[1], 10) }, configurePingInterval: function (t) { var e = t._, n = function (e) { f(t).triggerHandler(v.onError, [e]) }; if (!e.pingIntervalId && e.pingInterval) { e.pingIntervalId = i.setInterval(function () { d.transports._logic.pingServer(t).fail(n) }, e.pingInterval) } } }; d.events = v; d.ajaxDefaults = t; d.changeState = m; d.isDisconnecting = o; d.connectionState = { connecting: 0, connected: 1, reconnecting: 2, disconnected: 4 }; d.hub = { start: function () { throw new Error("SignalR: Error loading hubs. Ensure your hubs reference is correct, e.g. <script src='/signalr/hubs'><\/script>.") } }; if (typeof p.on == "function") { p.on("load", function () { g = true }) } else { p.load(function () { g = true }) } function validateTransport(e, t) { if (f.isArray(e)) { for (var n = e.length - 1; n >= 0; n--) { var o = e[n]; if (f.type(e) !== "object" && (f.type(o) !== "string" || !d.transports[o])) { t.log("Invalid transport: " + o + ", removing it from the transports list."); e.splice(n, 1) } } if (e.length === 0) { t.log("No transports remain within the specified transport array."); e = null } } else if (f.type(e) !== "object" && !d.transports[e] && e !== "auto") { t.log("Invalid transport: " + e.toString() + "."); e = null } else if (e === "auto" && d._.ieVersion <= 8) { return ["longPolling"] } return e } function getDefaultPort(e) { if (e === "http:") { return 80 } else if (e === "https:") { return 443 } } function addDefaultPort(e, t) { if (t.match(/:\d+$/)) { return t } else { return t + ":" + getDefaultPort(e) } } d.fn = d.prototype = { init: function (e, t, n) { this.url = e; this.qs = t; this._ = { keepAliveData: {}, negotiateAbortText: "__Negotiate Aborted__", pingAbortText: "__Ping Aborted__", pingIntervalId: null, pingInterval: 3e5, pollTimeoutId: null, reconnectTimeoutId: null, lastMessageAt: (new Date).getTime(), lastActiveAt: (new Date).getTime(), beatInterval: 5e3, beatHandle: null, activePings: {}, nextPingId: 0 }; if (typeof n === "boolean") { this.logging = n } }, _parseResponse: function (e) { var t = this; if (!e) { return e } else if (t.ajaxDataType === "text") { return t.json.parse(e) } else { return e } }, json: i.JSON, isCrossDomain: function (e, t) { var n; e = f.trim(e); t = t || i.location; if (e.indexOf("http") !== 0) { return false } n = i.document.createElement("a"); n.href = e; return n.protocol + addDefaultPort(n.protocol, n.host) !== t.protocol + addDefaultPort(t.protocol, t.host) }, ajaxDataType: "text", contentType: "application/json; charset=UTF-8", logging: false, state: d.connectionState.disconnected, reconnectDelay: 2e3, disconnectTimeout: 3e4, reconnectWindow: 3e4, keepAliveWarnAt: 2 / 3, start: function (e, n) { var a = this, c = { pingInterval: 3e5, waitForPageLoad: true, transport: "auto", jsonp: false }, s, l = a._deferral || f.Deferred(), t = i.document.createElement("a"); a._deferral = l; if (f.type(e) === "function") { n = e } else if (f.type(e) === "object") { f.extend(c, e); if (f.type(c.callback) === "function") { n = c.callback } } c.transport = validateTransport(c.transport, a); if (!c.transport) { throw new Error("SignalR: Invalid transport(s) specified, aborting start.") } a._.config = c; a._.pingInterval = c.pingInterval; if (!g && c.waitForPageLoad === true) { a._.deferredStartHandler = function () { a.start(e, n) }; p.bind("load", a._.deferredStartHandler); return l.promise() } if (a.state === d.connectionState.connecting) { return l.promise() } else if (m(a, d.connectionState.disconnected, d.connectionState.connecting) === false) { l.resolve(a); return l.promise() } h(a); t.href = a.url; if (!t.protocol || t.protocol === ":") { a.protocol = i.document.location.protocol; a.host = i.document.location.host; a.baseUrl = a.protocol + "//" + a.host } else { a.protocol = t.protocol; a.host = t.host; a.baseUrl = t.protocol + "//" + t.host } a.wsProtocol = a.protocol === "https:" ? "wss://" : "ws://"; if (c.transport === "auto" && c.jsonp === true) { c.transport = "longPolling" } if (a.url.indexOf("//") === 0) { a.url = i.location.protocol + a.url; a.log("Protocol relative URL detected, normalizing it to '" + a.url + "'.") } if (this.isCrossDomain(a.url)) { a.log("Auto detected cross domain url."); if (c.transport === "auto") { c.transport = ["webSockets", "longPolling"] } if (c.withCredentials === r) { c.withCredentials = true } if (!c.jsonp) { c.jsonp = !f.support.cors; if (c.jsonp) { a.log("Using jsonp because this browser doesn't support CORS.") } } a.contentType = d._.defaultContentType } a.withCredentials = c.withCredentials; a.ajaxDataType = c.jsonp ? "jsonp" : "text"; f(a).bind(v.onStart, function (e, t) { if (f.type(n) === "function") { n.call(a) } l.resolve(a) }); s = function (e, t) { t = t || 0; if (t >= e.length) { f(a).triggerHandler(v.onError, ["SignalR: No transport could be initialized successfully. Try specifying a different transport or none at all for auto initialization."]); l.reject("SignalR: No transport could be initialized successfully. Try specifying a different transport or none at all for auto initialization."); a.stop(); return } if (a.state === d.connectionState.disconnected) { return } var n = e[t], o = f.type(n) === "object" ? n : d.transports[n]; a.transport = o; if (n.indexOf("_") === 0) { s(e, t + 1); return } o.start(a, function () { var e = d._.firefoxMajorVersion(i.navigator.userAgent) >= 11, t = !!a.withCredentials && e; if (a.state === d.connectionState.disconnected) { return } if (o.supportsKeepAlive && a._.keepAliveData.activated) { d.transports._logic.monitorKeepAlive(a) } d.transports._logic.startHeartbeat(a); d._.configurePingInterval(a); m(a, d.connectionState.connecting, d.connectionState.connected); f(a).triggerHandler(v.onStart); p.bind("unload", function () { a.log("Window unloading, stopping the connection."); a.stop(t) }); if (d._.firefoxMajorVersion(i.navigator.userAgent) >= 11) { p.bind("beforeunload", function () { i.setTimeout(function () { a.stop(t) }, 0) }) } }, function () { s(e, t + 1) }) }; f(a).triggerHandler(v.onStarting); var o = a.url + "/negotiate", u = function (e, t) { f(t).triggerHandler(v.onError, [e.responseText]); l.reject("SignalR: Error during negotiation request: " + e.responseText); t.stop() }; o = d.transports._logic.prepareQueryString(a, o); a.log("Negotiating with '" + o + "'."); a._.negotiateRequest = f.ajax(f.extend({}, f.signalR.ajaxDefaults, { xhrFields: { withCredentials: a.withCredentials }, url: o, type: "GET", contentType: a.contentType, data: {}, dataType: a.ajaxDataType, error: function (e, t) { if (t !== a._.negotiateAbortText) { u(e, a) } else { l.reject("Stopped the connection while negotiating.") } }, success: function (e) { var t, n = a._.keepAliveData; try { t = a._parseResponse(e) } catch (i) { u(i, a); return } n = a._.keepAliveData; a.appRelativeUrl = t.Url; a.id = t.ConnectionId; a.token = t.ConnectionToken; a.webSocketServerUrl = t.WebSocketServerUrl; a.disconnectTimeout = t.DisconnectTimeout * 1e3; if (t.KeepAliveTimeout) { n.activated = true; n.timeout = t.KeepAliveTimeout * 1e3; n.timeoutWarning = n.timeout * a.keepAliveWarnAt; a._.beatInterval = (n.timeout - n.timeoutWarning) / 3 } else { n.activated = false } if (!t.ProtocolVersion || t.ProtocolVersion !== "1.2") { f(a).triggerHandler(v.onError, ["You are using a version of the client that isn't compatible with the server. Client version 1.2, server version " + t.ProtocolVersion + "."]); l.reject("You are using a version of the client that isn't compatible with the server. Client version 1.2, server version " + t.ProtocolVersion + "."); return } var o = [], r = []; f.each(d.transports, function (e) { if (e === "webSockets" && !t.TryWebSockets) { return true } r.push(e) }); if (f.isArray(c.transport)) { f.each(c.transport, function () { var e = this; if (f.type(e) === "object" || f.type(e) === "string" && f.inArray("" + e, r) >= 0) { o.push(f.type(e) === "string" ? "" + e : e) } }) } else if (f.type(c.transport) === "object" || f.inArray(c.transport, r) >= 0) { o.push(c.transport) } else { o = r } s(o) } })); return l.promise() }, starting: function (n) { var o = this; f(o).bind(v.onStarting, function (e, t) { n.call(o) }); return o }, send: function (e) { var t = this; if (t.state === d.connectionState.disconnected) { throw new Error("SignalR: Connection must be started before data can be sent. Call .start() before .send()") } if (t.state === d.connectionState.connecting) { throw new Error("SignalR: Connection has not been fully initialized. Use .start().done() or .start().fail() to run logic after the connection has started.") } t.transport.send(t, e); return t }, received: function (n) { var o = this; f(o).bind(v.onReceived, function (e, t) { n.call(o, t) }); return o }, stateChanged: function (n) { var o = this; f(o).bind(v.onStateChanged, function (e, t) { n.call(o, t) }); return o }, error: function (o) { var r = this; f(r).bind(v.onError, function (e, t, n) { o.call(r, t, n) }); return r }, disconnected: function (n) { var o = this; f(o).bind(v.onDisconnect, function (e, t) { n.call(o) }); return o }, connectionSlow: function (n) { var o = this; f(o).bind(v.onConnectionSlow, function (e, t) { n.call(o) }); return o }, reconnecting: function (n) { var o = this; f(o).bind(v.onReconnecting, function (e, t) { n.call(o) }); return o }, reconnected: function (n) { var o = this; f(o).bind(v.onReconnect, function (e, t) { n.call(o) }); return o }, stop: function (e, t) { var n = this, o = n._deferral, r = n._.config; if (n._.deferredStartHandler) { p.unbind("load", n._.deferredStartHandler) } delete n._deferral; delete n._.config; delete n._.deferredStartHandler; if (!g && (!r || r.waitForPageLoad === true)) { n.log("Stopping connection prior to negotiate."); if (o) { o.reject("The connection was stopped during page load.") } return } if (n.state === d.connectionState.disconnected) { return } n.log("Stopping connection."); m(n, n.state, d.connectionState.disconnected); i.clearTimeout(n._.beatHandle); i.clearInterval(n._.pingIntervalId); i.clearTimeout(n._.pingLoopId); if (n.transport) { if (t !== false) { n.transport.abort(n, e) } if (n.transport.supportsKeepAlive && n._.keepAliveData.activated) { d.transports._logic.stopMonitoringKeepAlive(n) } n.transport.stop(n); n.transport = null } if (n._.negotiateRequest) { n._.negotiateRequest.abort(n._.negotiateAbortText); delete n._.negotiateRequest } f.each(n._.activePings, function (e, t) { n.log("Aborting ping " + e + "."); t.abort(n._.pingAbortText) }); f(n).triggerHandler(v.onDisconnect); delete n.messageId; delete n.groupsToken; delete n.id; delete n._.pingIntervalId; delete n._.lastMessageAt; delete n._.lastActiveAt; delete n._.pingLoopId; return n }, log: function (e) { n(e, this.logging) } }; d.fn.init.prototype = d.fn; d.noConflict = function () { if (f.connection === d) { f.connection = e } return d }; if (f.connection) { e = f.connection } f.connection = f.signalR = d })(window.jQuery, window); (function (i, c, e) { "use strict"; var a = i.signalR, s = i.signalR.events, t = i.signalR.changeState, l; a.transports = {}; function beat(e) { if (e._.keepAliveData.monitoring) { checkIfAlive(e) } if (l.markActive(e)) { e._.beatHandle = c.setTimeout(function () { beat(e) }, e._.beatInterval) } } function checkIfAlive(e) { var t = e._.keepAliveData, n; if (e.state === a.connectionState.connected) { n = (new Date).getTime() - e._.lastMessageAt; if (n >= t.timeout) { e.log("Keep alive timed out.  Notifying transport that connection has been lost."); e.transport.lostConnection(e) } else if (n >= t.timeoutWarning) { if (!t.userNotified) { e.log("Keep alive has been missed, connection may be dead/slow."); i(e).triggerHandler(s.onConnectionSlow); t.userNotified = true } } else { t.userNotified = false } } } function isConnectedOrReconnecting(e) { return e.state === a.connectionState.connected || e.state === a.connectionState.reconnecting } function addConnectionData(e, t) { var n = e.indexOf("?") !== -1 ? "&" : "?"; if (t) { e += n + "connectionData=" + c.encodeURIComponent(t) } return e } l = a.transports._logic = { pingServer: function (o) { var e, r = i.Deferred(), t = o._.activePings, n = o._.nextPingId++; e = o.url + "/ping"; e = l.prepareQueryString(o, e); t[n] = i.ajax(i.extend({}, i.signalR.ajaxDefaults, { xhrFields: { withCredentials: o.withCredentials }, url: e, type: "GET", contentType: o.contentType, data: {}, dataType: o.ajaxDataType, success: function (e) { var t; try { t = o._parseResponse(e) } catch (n) { r.reject("Failed to parse ping server response, stopping the connection: " + e); o.stop(); return } if (t.Response === "pong") { r.resolve() } else { r.reject("SignalR: Invalid ping response when pinging server: " + t.Response) } }, error: function (e, t) { if (e.status === 401 || e.status === 403) { r.reject("Failed to ping server. Server responded with a " + e.status + " status code, stopping the connection."); o.stop() } else if (t === o._.pingAbortText) { o.log("Ping " + n + " aborted.") } else { r.reject("SignalR: Error pinging server: " + (e.responseText || e.statusText)) } }, complete: function () { delete t[n] } })); return r.promise() }, prepareQueryString: function (e, t) { t = l.addQs(t, e); return addConnectionData(t, e.data) }, addQs: function (e, t) { var n = e.indexOf("?") !== -1 ? "&" : "?", o; if (!t.qs) { return e } if (typeof t.qs === "object") { return e + n + i.param(t.qs) } if (typeof t.qs === "string") { o = t.qs.charAt(0); if (o === "?" || o === "&") { n = "" } return e + n + t.qs } throw new Error("Connections query string property must be either a string or object.") }, getUrl: function (e, t, n, o) { var r = t === "webSockets" ? "" : e.baseUrl, i = r + e.appRelativeUrl, a = "transport=" + t + "&connectionToken=" + c.encodeURIComponent(e.token); if (e.groupsToken) { a += "&groupsToken=" + c.encodeURIComponent(e.groupsToken) } if (!n) { i += "/connect" } else { if (o) { i += "/poll" } else { i += "/reconnect" } if (e.messageId) { a += "&messageId=" + c.encodeURIComponent(e.messageId) } } i += "?" + a; i = l.prepareQueryString(e, i); i += "&tid=" + Math.floor(Math.random() * 11); return i }, maximizePersistentResponse: function (e) { return { MessageId: e.C, Messages: e.M, Disconnect: typeof e.D !== "undefined" ? true : false, ShouldReconnect: typeof e.T !== "undefined" ? true : false, LongPollDelay: e.L, GroupsToken: e.G } }, updateGroups: function (e, t) { if (t) { e.groupsToken = t } }, ajaxSend: function (o, n) { var e = o.url + "/send" + "?transport=" + o.transport.name + "&connectionToken=" + c.encodeURIComponent(o.token), r = function (e, t) { i(t).triggerHandler(s.onError, [e, n]) }; e = l.prepareQueryString(o, e); return i.ajax(i.extend({}, i.signalR.ajaxDefaults, { xhrFields: { withCredentials: o.withCredentials }, url: e, type: o.ajaxDataType === "jsonp" ? "GET" : "POST", contentType: a._.defaultContentType, dataType: o.ajaxDataType, data: { data: n }, success: function (e) { var t; if (e) { try { t = o._parseResponse(e) } catch (n) { r(n, o); o.stop(); return } i(o).triggerHandler(s.onReceived, [t]) } }, error: function (e, t) { if (t === "abort" || t === "parsererror") { return } r(e, o) } })) }, ajaxAbort: function (e, t) { if (typeof e.transport === "undefined") { return } t = typeof t === "undefined" ? true : t; var n = e.url + "/abort" + "?transport=" + e.transport.name + "&connectionToken=" + c.encodeURIComponent(e.token); n = l.prepareQueryString(e, n); i.ajax(i.extend({}, i.signalR.ajaxDefaults, { xhrFields: { withCredentials: e.withCredentials }, url: n, async: t, timeout: 1e3, type: "POST", contentType: e.contentType, dataType: e.ajaxDataType, data: {} })); e.log("Fired ajax abort async = " + t + ".") }, processMessages: function (e, t) { var n; if (e.transport) { var o = i(e); l.markLastMessage(e); if (!t) { return } n = this.maximizePersistentResponse(t); if (n.Disconnect) { e.log("Disconnect command received from server."); e.stop(false, false); return } this.updateGroups(e, n.GroupsToken); if (n.Messages) { i.each(n.Messages, function (e, t) { o.triggerHandler(s.onReceived, [t]) }) } if (n.MessageId) { e.messageId = n.MessageId } } }, monitorKeepAlive: function (e) { var t = e._.keepAliveData; if (!t.monitoring) { t.monitoring = true; l.markLastMessage(e); e._.keepAliveData.reconnectKeepAliveUpdate = function () { l.markLastMessage(e) }; i(e).bind(s.onReconnect, e._.keepAliveData.reconnectKeepAliveUpdate); e.log("Now monitoring keep alive with a warning timeout of " + t.timeoutWarning + " and a connection lost timeout of " + t.timeout + ".") } else { e.log("Tried to monitor keep alive but it's already being monitored.") } }, stopMonitoringKeepAlive: function (e) { var t = e._.keepAliveData; if (t.monitoring) { t.monitoring = false; i(e).unbind(s.onReconnect, e._.keepAliveData.reconnectKeepAliveUpdate); e._.keepAliveData = {}; e.log("Stopping the monitoring of the keep alive.") } }, startHeartbeat: function (e) { beat(e) }, markLastMessage: function (e) { e._.lastMessageAt = (new Date).getTime() }, markActive: function (e) { if (l.verifyLastActive(e)) { e._.lastActiveAt = (new Date).getTime(); return true } return false }, ensureReconnectingState: function (e) { if (t(e, a.connectionState.connected, a.connectionState.reconnecting) === true) { i(e).triggerHandler(s.onReconnecting) } return e.state === a.connectionState.reconnecting }, clearReconnectTimeout: function (e) { if (e && e._.reconnectTimeout) { c.clearTimeout(e._.reconnectTimeout); delete e._.reconnectTimeout } }, verifyLastActive: function (e) { if ((new Date).getTime() - e._.lastActiveAt >= e.reconnectWindow) { e.log("There has not been an active server connection for an extended periord of time. Stopping connection."); e.stop(); return false } return true }, reconnect: function (e, t) { var n = a.transports[t], o = this; if (isConnectedOrReconnecting(e) && !e._.reconnectTimeout) { if (!l.verifyLastActive(e)) { return } e._.reconnectTimeout = c.setTimeout(function () { if (!l.verifyLastActive(e)) { return } n.stop(e); if (o.ensureReconnectingState(e)) { e.log(t + " reconnecting."); n.start(e) } }, e.reconnectDelay) } }, handleParseFailure: function (e, t, n, o) { if (e.state === a.connectionState.connecting) { e.log("Failed to parse server response while attempting to connect."); o() } else { i(e).triggerHandler(s.onError, ["SignalR: failed at parsing response: " + t + ".  With error: " + n]); e.stop() } }, foreverFrame: { count: 0, connections: {} } } })(window.jQuery, window); (function (l, u, e) { "use strict"; var f = l.signalR, d = l.signalR.events, g = l.signalR.changeState, p = f.transports._logic; f.transports.webSockets = { name: "webSockets", supportsKeepAlive: true, timeOut: 3e3, send: function (e, t) { e.socket.send(t) }, start: function (r, i, a) { var e, t = false, n = this, o, c, s = !i; if (!u.WebSocket) { a(); return } if (!r.socket) { if (r.webSocketServerUrl) { e = r.webSocketServerUrl } else { e = r.wsProtocol + r.host } e += p.getUrl(r, this.name, s); r.log("Connecting to websocket endpoint '" + e + "'."); r.socket = new u.WebSocket(e); if (a) { o = r.socket; c = u.setTimeout(function () { if (o === r.socket) { r.log("WebSocket timed out trying to connect."); a() } }, n.timeOut) } r.socket.onopen = function () { u.clearTimeout(c); t = true; r.log("Websocket opened.") }; r.socket.onclose = function (e) { u.clearTimeout(c); if (this === r.socket) { if (!t) { if (a) { a() } else if (s) { n.reconnect(r) } return } else if (typeof e.wasClean !== "undefined" && e.wasClean === false) { l(r).triggerHandler(d.onError, [e.reason]); r.log("Unclean disconnect from websocket: " + e.reason || "[no reason given].") } else { r.log("Websocket closed.") } n.reconnect(r) } }; r.socket.onmessage = function (e) { var t, n = l(r); try { t = r._parseResponse(e.data) } catch (o) { p.handleParseFailure(r, e.data, o.message, a); return } if (i) { i(); i = null } else if (g(r, f.connectionState.reconnecting, f.connectionState.connected) === true) { n.triggerHandler(d.onReconnect) } p.clearReconnectTimeout(r); if (t) { if (l.isEmptyObject(t) || t.M) { p.processMessages(r, t) } else { n.triggerHandler(d.onReceived, [t]) } } } } }, reconnect: function (e) { p.reconnect(e, this.name) }, lostConnection: function (e) { this.reconnect(e) }, stop: function (e) { p.clearReconnectTimeout(e); if (e.socket !== null) { e.log("Closing the Websocket."); e.socket.close(); e.socket = null } }, abort: function (e, t) { p.ajaxAbort(e, t) } } })(window.jQuery, window); (function (u, f, e) { "use strict"; var d = u.signalR, g = u.signalR.events, p = u.signalR.changeState, v = d.transports._logic; d.transports.serverSentEvents = { name: "serverSentEvents", supportsKeepAlive: true, timeOut: 3e3, start: function (o, r, i) { var t = this, n = false, a = u(o), e = !r, c, s; if (o.eventSource) { o.log("The connection already has an event source. Stopping it."); o.stop() } if (!f.EventSource) { if (i) { o.log("This browser doesn't support SSE."); i() } return } c = v.getUrl(o, this.name, e); try { o.log("Attempting to connect to SSE endpoint '" + c + "'."); o.eventSource = new f.EventSource(c) } catch (l) { o.log("EventSource failed trying to connect with error " + l.Message + "."); if (i) { i() } else { a.triggerHandler(g.onError, [l]); if (e) { t.reconnect(o) } } return } s = f.setTimeout(function () { if (n === false && o.eventSource) { o.log("EventSource timed out trying to connect."); o.log("EventSource readyState: " + o.eventSource.readyState + "."); if (!e) { t.stop(o) } if (e) { if (o.eventSource.readyState !== f.EventSource.OPEN) { t.reconnect(o) } } else if (i) { i() } } }, t.timeOut); o.eventSource.addEventListener("open", function (e) { o.log("EventSource connected."); if (s) { f.clearTimeout(s) } v.clearReconnectTimeout(o); if (n === false) { n = true; if (r) { r() } else if (p(o, d.connectionState.reconnecting, d.connectionState.connected) === true) { a.triggerHandler(g.onReconnect) } } }, false); o.eventSource.addEventListener("message", function (e) { var t; if (e.data === "initialized") { return } try { t = o._parseResponse(e.data) } catch (n) { v.handleParseFailure(o, e.data, n.message, i); return } v.processMessages(o, t, r) }, false); o.eventSource.addEventListener("error", function (e) { if (this === o.eventSource) { if (!n) { if (i) { i() } return } o.log("EventSource readyState: " + o.eventSource.readyState + "."); if (e.eventPhase === f.EventSource.CLOSED) { o.log("EventSource reconnecting due to the server connection ending."); t.reconnect(o) } else { o.log("EventSource error."); a.triggerHandler(g.onError) } } }, false) }, reconnect: function (e) { v.reconnect(e, this.name) }, lostConnection: function (e) { this.reconnect(e) }, send: function (e, t) { v.ajaxSend(e, t) }, stop: function (e) { v.clearReconnectTimeout(e); if (e && e.eventSource) { e.log("EventSource calling close()."); e.eventSource.close(); e.eventSource = null; delete e.eventSource } }, abort: function (e, t) { v.ajaxAbort(e, t) } } })(window.jQuery, window); (function (r, s, e) { "use strict"; var i = r.signalR, t = r.signalR.events, n = r.signalR.changeState, l = i.transports._logic, u = function () { var e = s.document.createElement("iframe"); e.setAttribute("style", "position:absolute;top:0;left:0;width:0;height:0;visibility:hidden;"); return e }, f = function () { var e = null, t = 1e3, n = 0; return { prevent: function () { if (i._.ieVersion <= 8) { if (n === 0) { e = s.setInterval(function () { var e = u(); s.document.body.appendChild(e); s.document.body.removeChild(e); e = null }, t) } n++ } }, cancel: function () { if (n === 1) { s.clearInterval(e) } if (n > 0) { n-- } } } }(); i.transports.foreverFrame = { name: "foreverFrame", supportsKeepAlive: true, timeOut: 3e3, iframeClearThreshold: 50, start: function (e, t, n) { var o = this, r = l.foreverFrame.count += 1, i, a = u(), c = function () { e.log("Forever frame iframe finished loading and is no longer receiving messages, reconnecting."); o.reconnect(e) }; if (s.EventSource) { if (n) { e.log("This browser supports SSE, skipping Forever Frame."); n() } return } a.setAttribute("data-signalr-connection-id", e.id); f.prevent(); i = l.getUrl(e, this.name); i += "&frameId=" + r; s.document.body.appendChild(a); e.log("Binding to iframe's load event."); if (a.addEventListener) { a.addEventListener("load", c, false) } else if (a.attachEvent) { a.attachEvent("onload", c) } a.src = i; l.foreverFrame.connections[r] = e; e.frame = a; e.frameId = r; if (t) { e.onSuccess = function () { e.log("Iframe transport started."); t() } } s.setTimeout(function () { if (e.onSuccess) { e.log("Failed to connect using forever frame source, it timed out after " + o.timeOut + "ms."); o.stop(e); if (n) { n() } } }, o.timeOut) }, reconnect: function (n) { var o = this; if (!l.verifyLastActive(n)) { return } s.setTimeout(function () { if (!l.verifyLastActive(n)) { return } if (n.frame && l.ensureReconnectingState(n)) { var e = n.frame, t = l.getUrl(n, o.name, true) + "&frameId=" + n.frameId; n.log("Updating iframe src to '" + t + "'."); e.src = t } }, n.reconnectDelay) }, lostConnection: function (e) { this.reconnect(e) }, send: function (e, t) { l.ajaxSend(e, t) }, receive: function (e, t) { var n, o; l.processMessages(e, t); e.frameMessageCount = (e.frameMessageCount || 0) + 1; if (e.frameMessageCount > i.transports.foreverFrame.iframeClearThreshold && e.state === r.signalR.connectionState.connected) { e.frameMessageCount = 0; n = e.frame.contentWindow || e.frame.contentDocument; if (n && n.document && n.document.body) { o = n.document.body; while (o.firstChild) { o.removeChild(o.firstChild) } } } }, stop: function (e) { var t = null; f.cancel(); if (e.frame) { if (e.frame.stop) { e.frame.stop() } else { try { t = e.frame.contentWindow || e.frame.contentDocument; if (t.document && t.document.execCommand) { t.document.execCommand("Stop") } } catch (n) { e.log("Error occured when stopping foreverFrame transport. Message = " + n.message + ".") } } if (e.frame.parentNode === s.document.body) { s.document.body.removeChild(e.frame) } delete l.foreverFrame.connections[e.frameId]; e.frame = null; e.frameId = null; delete e.frame; delete e.frameId; delete e.frameMessageCount; e.log("Stopping forever frame.") } }, abort: function (e, t) { l.ajaxAbort(e, t) }, getConnection: function (e) { return l.foreverFrame.connections[e] }, started: function (e) { if (e.onSuccess) { e.onSuccess(); e.onSuccess = null; delete e.onSuccess } else if (n(e, i.connectionState.reconnecting, i.connectionState.connected) === true) { r(e).triggerHandler(t.onReconnect) } } } })(window.jQuery, window); (function (v, m, e) { "use strict"; var h = v.signalR, b = v.signalR.events, n = v.signalR.changeState, S = v.signalR.isDisconnecting, y = h.transports._logic; h.transports.longPolling = { name: "longPolling", supportsKeepAlive: false, reconnectDelay: 3e3, init: function (t, e) { var n = this, o, r = function (e) { if (S(t) === false) { t.log("Server ping failed because '" + e + "', re-trying ping."); t._.pingLoopId = m.setTimeout(o, n.reconnectDelay) } }; t.log("Initializing long polling connection with server."); o = function () { y.pingServer(t).done(e).fail(r) }; o() }, start: function (c, e, t) { var s = this, l = function () { u = l = v.noop; c.log("Longpolling connected."); e(); t = null }, u = function () { if (t) { t(); t = null; c.log("LongPolling failed to connect."); return true } return false }, f = c._, d = 0, g = function (e) { m.clearTimeout(f.reconnectTimeoutId); f.reconnectTimeoutId = null; if (n(c, h.connectionState.reconnecting, h.connectionState.connected) === true) { c.log("Raising the reconnect event."); v(e).triggerHandler(b.onReconnect) } }, p = 36e5; if (c.pollXhr) { c.log("Polling xhr requests already exists, aborting."); c.stop() } f.reconnectTimeoutId = null; f.pollTimeoutId = null; s.init(c, function () { c.messageId = null; f.pollTimeoutId = m.setTimeout(function () { (function poll(a, e) { var t = a.messageId, n = t === null, o = !n, r = !e, i = y.getUrl(a, s.name, o, r); if (S(a) === true) { return } c.log("Opening long polling request to '" + i + "'."); a.pollXhr = v.ajax(v.extend({}, v.signalR.ajaxDefaults, { xhrFields: { withCredentials: c.withCredentials }, url: i, type: "GET", dataType: c.ajaxDataType, contentType: c.contentType, success: function (e) { var t = 0, n, o, r; c.log("Long poll complete."); d = 0; try { n = c._parseResponse(e) } catch (i) { y.handleParseFailure(a, e, i.message, u); return } if (f.reconnectTimeoutId !== null) { g() } l(); if (n) { o = y.maximizePersistentResponse(n) } y.processMessages(a, n); if (o && v.type(o.LongPollDelay) === "number") { t = o.LongPollDelay } if (o && o.Disconnect) { return } if (S(a) === true) { return } r = o && o.ShouldReconnect; if (r) { y.ensureReconnectingState(a) } if (t > 0) { f.pollTimeoutId = m.setTimeout(function () { poll(a, r) }, t) } else { poll(a, r) } }, error: function (e, t) { m.clearTimeout(f.reconnectTimeoutId); f.reconnectTimeoutId = null; if (t === "abort") { c.log("Aborted xhr requst."); return } if (!u()) { d++; if (c.state !== h.connectionState.reconnecting) { c.log("An error occurred using longPolling. Status = " + t + ".  Response = " + e.responseText + "."); v(a).triggerHandler(b.onError, [e.responseText]) } if ((c.state === h.connectionState.connected || c.state === h.connectionState.reconnecting) && !y.verifyLastActive(c)) { return } if (!y.ensureReconnectingState(a)) { return } f.pollTimeoutId = m.setTimeout(function () { s.init(a, function () { poll(a, true) }) }, s.reconnectDelay) } } })); if (o && e === true) { f.reconnectTimeoutId = m.setTimeout(function () { g(a) }, Math.min(1e3 * (Math.pow(2, d) - 1), p)) } })(c); m.setTimeout(function () { l() }, 250) }, 250) }) }, lostConnection: function (e) { throw new Error("Lost Connection not handled for LongPolling") }, send: function (e, t) { y.ajaxSend(e, t) }, stop: function (e) { m.clearTimeout(e._.pollTimeoutId); m.clearTimeout(e._.reconnectTimeoutId); delete e._.pollTimeoutId; delete e._.reconnectTimeoutId; if (e.pollXhr) { e.pollXhr.abort(); e.pollXhr = null; delete e.pollXhr } }, abort: function (e, t) { y.ajaxAbort(e, t) } } })(window.jQuery, window); (function (s, e, t) { "use strict"; var n = ".hubProxy"; function makeEventName(e) { return e + n } function map(e, t, n) { var o, r = e.length, i = []; for (o = 0; o < r; o += 1) { if (e.hasOwnProperty(o)) { i[o] = t.call(n, e[o], o, e) } } return i } function getArgValue(e) { return s.isFunction(e) ? null : s.type(e) === "undefined" ? null : e } function hasMembers(e) { for (var t in e) { if (e.hasOwnProperty(t)) { return true } } return false } function clearInvocationCallbacks(e, t) { var n = e._.invocationCallbacks, o; if (hasMembers(n)) { e.log("Clearing hub invocation callbacks with error: " + t + ".") } e._.invocationCallbackId = 0; delete e._.invocationCallbacks; e._.invocationCallbacks = {}; for (var r in n) { o = n[r]; o.method.call(o.scope, { E: t }) } } function hubProxy(e, t) { return new hubProxy.fn.init(e, t) } hubProxy.fn = hubProxy.prototype = { init: function (e, t) { this.state = {}; this.connection = e; this.hubName = t; this._ = { callbackMap: {} } }, hasSubscriptions: function () { return hasMembers(this._.callbackMap) }, on: function (e, n) { var o = this, t = o._.callbackMap; e = e.toLowerCase(); if (!t[e]) { t[e] = {} } t[e][n] = function (e, t) { n.apply(o, t) }; s(o).bind(makeEventName(e), t[e][n]); return o }, off: function (e, t) { var n = this, o = n._.callbackMap, r; e = e.toLowerCase(); r = o[e]; if (r) { if (r[t]) { s(n).unbind(makeEventName(e), r[t]); delete r[t]; if (!hasMembers(r)) { delete o[e] } } else if (!t) { s(n).unbind(makeEventName(e)); delete o[e] } } return n }, invoke: function (e) { var n = this, o = n.connection, t = s.makeArray(arguments).slice(1), r = map(t, getArgValue), i = { H: n.hubName, M: e, A: r, I: o._.invocationCallbackId }, a = s.Deferred(), c = function (e) { var t = n._maximizeHubResponse(e); s.extend(n.state, t.State); if (t.Error) { if (t.StackTrace) { o.log(t.Error + "\n" + t.StackTrace + ".") } a.rejectWith(n, [t.Error]) } else { a.resolveWith(n, [t.Result]) } }; o._.invocationCallbacks[o._.invocationCallbackId.toString()] = { scope: n, method: c }; o._.invocationCallbackId += 1; if (!s.isEmptyObject(n.state)) { i.S = n.state } o.send(n.connection.json.stringify(i)); return a.promise() }, _maximizeHubResponse: function (e) { return { State: e.S, Result: e.R, Id: e.I, Error: e.E, StackTrace: e.T } } }; hubProxy.fn.init.prototype = hubProxy.fn; function hubConnection(e, t) { var n = { qs: null, logging: false, useDefaultPath: true }; s.extend(n, t); if (!e || n.useDefaultPath) { e = (e || "") + "/signalr" } return new hubConnection.fn.init(e, n) } hubConnection.fn = hubConnection.prototype = s.connection(); hubConnection.fn.init = function (e, t) { var n = { qs: null, logging: false, useDefaultPath: true }, c = this; s.extend(n, t); s.signalR.fn.init.call(c, e, n.qs, n.logging); c.proxies = {}; c._.invocationCallbackId = 0; c._.invocationCallbacks = {}; c.received(function (e) { var t, n, o, r, i, a; if (!e) { return } if (typeof e.I !== "undefined") { o = e.I.toString(); r = c._.invocationCallbacks[o]; if (r) { c._.invocationCallbacks[o] = null; delete c._.invocationCallbacks[o]; r.method.call(r.scope, e) } } else { t = this._maximizeClientHubInvocation(e); c.log("Triggering client hub event '" + t.Method + "' on hub '" + t.Hub + "'."); i = t.Hub.toLowerCase(); a = t.Method.toLowerCase(); n = this.proxies[i]; s.extend(n.state, t.State); s(n).triggerHandler(makeEventName(a), [t.Args]) } }); c.error(function (e, t) { var n, o; if (c.transport && c.transport.name === "webSockets") { return } if (!t) { return } try { t = c.json.parse(t) } catch (r) { return } n = t.I; o = c._.invocationCallbacks[n]; if (o) { c._.invocationCallbacks[n] = null; delete c._.invocationCallbacks[n]; o.method.call(o.scope, { E: e }) } }); c.reconnecting(function () { if (c.transport && c.transport.name === "webSockets") { clearInvocationCallbacks(c, "Connection started reconnecting before invocation result was received.") } }); c.disconnected(function () { clearInvocationCallbacks(c, "Connection was disconnected before invocation result was received.") }) }; hubConnection.fn._maximizeClientHubInvocation = function (e) { return { Hub: e.H, Method: e.M, Args: e.A, State: e.S } }; hubConnection.fn._registerSubscribedHubs = function () { var n = this; if (!n._subscribedToHubs) { n._subscribedToHubs = true; n.starting(function () { var t = []; s.each(n.proxies, function (e) { if (this.hasSubscriptions()) { t.push({ name: e }); n.log("Client subscribed to hub '" + e + "'.") } }); if (t.length === 0) { n.log("No hubs have been subscribed to.  The client will not receive data from hubs.  To fix, declare at least one client side function prior to connection start for each hub you wish to subscribe to.") } n.data = n.json.stringify(t) }) } }; hubConnection.fn.createHubProxy = function (e) { e = e.toLowerCase(); var t = this.proxies[e]; if (!t) { t = hubProxy(this, e); this.proxies[e] = t } this._registerSubscribedHubs(); return t }; hubConnection.fn.init.prototype = hubConnection.fn; s.hubConnection = hubConnection })(window.jQuery, window); (function (e, t) { e.signalR.version = "1.2.1" })(window.jQuery);
